<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Collaboration Detail</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <script type="module" src="https://rw-501.github.io/contenthub/js/firebase-config.js" defer></script>
  <link rel="stylesheet" href="https://rw-501.github.io/contenthub/css/main.css" />
  <style>
    #chatBox { height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background: #fff; }
    #chatBox .msg { margin-bottom: 10px; }
    .task { display: block;  align-items: center; margin-bottom: 6px; }
    .edit-btn { cursor: pointer; color: blue; font-size: 0.9rem; }

    #mentionsDropdown {
  min-width: 200px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 6px;
  max-height: 200px;
  overflow-y: auto;
}

  </style>
</head>
<body>
    
      <div id="toolbarContainer"></div>

  <!-- Your page content here -->

  <!-- Include Bootstrap JS (required for navbar) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Inject toolbar -->
  <script type="module">
    const toolbarContainer = document.getElementById("toolbarContainer");
    const html = await fetch('https://rw-501.github.io/contenthub/includes/nav.html').then(res => res.text());
    toolbarContainer.innerHTML = html;
    import('https://rw-501.github.io/contenthub/includes/nav.js');
  </script>

  <main id="main">
    <div class="container py-4">

  <!-- Header -->
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h2 id="collabTitle">Loading...</h2>
    <span id="editControls" class="d-none">
      <button class="btn btn-sm btn-outline-secondary" id="editCollab">✏️ Edit</button>
    </span>
  </div>
  <p id="collabDesc" class="small"></p>

  <!-- Media Preview -->
  <div id="mediaPreview" class="mb-3"></div>

  <!-- Visibility Toggle -->
  <div class="form-check form-switch mb-4">
    <input class="form-check-input" type="checkbox" id="publicToggle" />
    <label class="form-check-label" for="publicToggle">Visible in Collab Zone</label>
  </div>

  <!-- Chat Section -->
  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0">💬 Chat <small id="typingStatus" class="text-muted"></small></h5>
      <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#chatSection">Toggle</button>
    </div>
    <div class="collapse show" id="chatSection">
      <div class="card-body">
        <div id="mentionsDropdown" class="dropdown-menu show" style="position:absolute; display:none; z-index:9999;"></div>
        <div id="chatBox" class="mb-3" style="max-height: 300px; overflow-y: auto;"></div>
<div class="input-group align-items-end">
<div id="chatInput" contenteditable="true" class="form-control" style="min-height: 60px;"></div>
      </div>

        <div class="d-flex">
<input type="file" id="chatMedia" hidden />
<button class="btn btn-outline-secondary" onclick="document.getElementById('chatMedia').click()">📎</button>
  <button class="btn btn-outline-primary" id="sendChat">Send</button>
  </div>
</div>

    </div>
  </div>

  <!-- Shared Board -->
  <div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0">📌 Shared Board</h5>
      <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#taskBoard">Toggle</button>
    </div>
    <div class="collapse show" id="taskBoard">
      <div class="card-body">

        <!-- Progress Bar -->
        <div class="progress mb-3" id="taskProgressBar" style="height: 20px;">
          <div class="progress-bar bg-success" role="progressbar" id="progressBarFill" style="width: 0%;"></div>
        </div>


<!-- Filters -->
<div class="mb-3 d-flex flex-wrap gap-2 align-items-end">
  <div>
    <label for="filterGoal" class="form-label" data-bs-toggle="tooltip" title="Filter tasks based on goal or category">🎯 Filter by Goal</label>
    <select id="filterGoal" class="form-select w-auto">
      <option value="">All Goals</option>
    </select>
  </div>
  <div>
    <label for="filterAssignee" class="form-label" data-bs-toggle="tooltip" title="Filter tasks by who it's assigned to">👤 Filter by Assignee</label>
    <select id="filterAssignee" class="form-select w-auto">
      <option value="">All Assignees</option>
    </select>
  </div>
</div>

<!-- Task List -->
<div id="taskList" class="mb-4"></div>

<!-- Task Form -->
<div class="card">
  <div class="card-header d-flex justify-content-between align-items-center">
    <h6 class="mb-0">➕ Add New Task</h6>
    <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#taskForm">Toggle</button>
  </div>
  <div class="collapse show" id="taskForm">
    <div class="card-body">
      <div class="row g-3">

        <div class="col-md-4">
          <label for="newTask" class="form-label" data-bs-toggle="tooltip" title="Name of the task or paste a relevant link">📝 Task Name or Link</label>
          <input type="text" id="newTask" class="form-control" placeholder="Write task or paste a URL..." />
          <div id="taskPreview" class="mt-2 small text-muted"></div>
        </div>

        <div class="col-md-3">
          <label for="taskGoal" class="form-label" data-bs-toggle="tooltip" title="Category or purpose of the task">🎯 Goal / Category</label>
          <input type="text" id="taskGoal" class="form-control" placeholder="e.g. Design, Outreach" />
        </div>

        <div class="col-md-2">
          <label for="taskOrder" class="form-label" data-bs-toggle="tooltip" title="Display order of the task (lower appears first)">🔢 Order</label>
          <input type="number" id="taskOrder" class="form-control" placeholder="Sort priority" min="1" />
        </div>

        <div class="col-md-3">
          <label for="taskDeadline" class="form-label" data-bs-toggle="tooltip" title="When is this task due? Must be a future date.">🕒 Deadline</label>
          <input type="date" id="taskDeadline" class="form-control" />
        </div>

        <div class="col-md-4 position-relative">
          <label for="taskAssignee" class="form-label" data-bs-toggle="tooltip" title="Assign to a team member (auto-complete enabled)">👤 Assign to (User ID)</label>
<input type="text" id="taskAssignee" class="form-control" placeholder="Assign to user..." list="assigneeList" />
<datalist id="assigneeList"></datalist>

        </div>

        <div class="col-md-5">
          <label for="taskLinks" class="form-label" data-bs-toggle="tooltip" title="Relevant links for this task (comma separated)">📎 Related Links</label>
          <input type="text" id="taskLinks" class="form-control" placeholder="Comma-separated URLs" />
          <div id="linkPreview" class="mt-2 small"></div>
        </div>

        <div class="col-md-3 d-grid">
          <label class="form-label invisible">Add Button</label>
          <button class="btn btn-success" id="addTask">➕ Add Task</button>
        </div>

      </div>
    </div>
  </div>
</div>


      </div>
    </div>
  </div>


<!-- Timeline Section -->
<div class="card mb-4">
  <div class="card-header d-flex justify-content-between align-items-center">
    <h5 class="mb-0">📜 Activity Timeline</h5>
    <button class="btn btn-sm btn-outline-secondary" 
            data-bs-toggle="collapse" 
            data-bs-target="#timelineSection"
            aria-expanded="true" 
            aria-controls="timelineSection">
      Toggle
    </button>
  </div>
  <div class="collapse show" id="timelineSection">
    <div class="card-body">
      <ul id="timeline" class="list-group list-group-flush mb-0"></ul>
    </div>
  </div>
</div>


</div>

  </main>



<script src="https://unpkg.com/timeago.js@4.0.2/dist/timeago.min.js"></script>

  <div id="footerContainer"></div>
  <script type="module">
import { getFirestore, doc, getDoc, updateDoc, collection, onSnapshot, arrayUnion, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { db, auth } from 'https://rw-501.github.io/contenthub/js/firebase-config.js';
import { v4 as uuidv4 } from "https://jspm.dev/uuid"; // You can use any UUID lib


    const urlParams = new URLSearchParams(window.location.search);
const collabId = urlParams.get("id");

console.log("Full URL:", window.location.href);
console.log("Search Params:", window.location.search);
console.log("Collab ID:", collabId);

    const titleEl = document.getElementById("collabTitle");
    const descEl = document.getElementById("collabDesc");
    const mediaPreview = document.getElementById("mediaPreview");
    const publicToggle = document.getElementById("publicToggle");
    const chatBox = document.getElementById("chatBox");
    const chatInput = document.getElementById("chatInput");
    const sendChat = document.getElementById("sendChat");
    const taskList = document.getElementById("taskList");
    const newTask = document.getElementById("newTask");
    const addTask = document.getElementById("addTask");
    const editControls = document.getElementById("editControls");
    const typingStatus = document.getElementById("typingStatus");

    let currentUser = null;
    let typingTimeout;

    auth.onAuthStateChanged(user => {
      if (user) {
        currentUser = user;
        loadCollab();
      }
    });

function sanitize(text) {
  if (typeof text !== "string") {
    console.warn("sanitize() expected string but got:", text);
  }
  text = String(text || "");
  return text
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>')
    .replace(/@([\w]+)/g, '<span class="text-primary">@$1</span>');
}

// ✅ Render Timeline with avatars, roles, display names
function renderTimeline(entries) {
  const timelineEl = document.getElementById("timeline");
  timelineEl.innerHTML = "";

  if (!entries.length) {
    timelineEl.innerHTML = `<li class="list-group-item text-muted">No activity yet.</li>`;
    return;
  }

  const sorted = entries.sort((a, b) => b.timestamp - a.timestamp);
  sorted.forEach(entry => {
    const time = new Date(entry.timestamp).toLocaleString([], {
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });

    const userName = entry.user?.displayName || entry.user?.email || "Unknown";
    const userRole = entry.user?.role ? ` <small class="text-muted">(${entry.user.role})</small>` : "";
    const avatar = entry.user?.photoURL
      ? `<img src="${entry.user.photoURL}" class="rounded-circle me-2" style="width:32px;height:32px;object-fit:cover;">`
      : `<span class="avatar-placeholder me-2">👤</span>`;

    const li = document.createElement("li");
    li.className = "list-group-item d-flex align-items-start gap-2";
    li.innerHTML = `
      ${avatar}
      <div>
        <div>${userName}${userRole} ${getActionText(entry.type, entry.details)}</div>
        <small class="text-muted">${time}</small>
      </div>
    `;
    timelineEl.appendChild(li);
  });
}

// ✅ Action descriptions
function getActionText(type, details) {
  switch (type) {
    case "added_task": return `📝 added task <strong>${details}</strong>`;
    case "deleted_task": return `🗑️ deleted task <strong>${details}</strong>`;
    case "pinned_task": return `📌 pinned task <strong>${details}</strong>`;
    case "updated_collab": return `✏️ updated the collaboration`;
    case "checked_task": return `Checked task ${details}`;
    case "visibility_toggle": return `🔓 ${details}`;
    case "added_goal": return `🎯 added goal <strong>${details}</strong>`;
    default: return `<strong>${details}</strong>`;
  }
}


    async function loadCollab() {
      const collabRef = doc(db, "collaborations", collabId);
      const snap = await getDoc(collabRef);
      if (!snap.exists()) return alert("Collaboration not found");

      const data = snap.data();
      const isParticipant = data.participants.includes(currentUser.uid);
      if (!isParticipant) return alert("Access denied");

const assigneeListEl = document.getElementById("assigneeList");

// Optional: Clear previous values
assigneeListEl.innerHTML = "";

// Fetch participant names or emails
const participantIds = data.participants || [];
const usersCollection = collection(db, "users"); // adjust path if needed

for (const uid of participantIds) {
  const userRef = doc(usersCollection, uid);
  const userSnap = await getDoc(userRef);
  if (userSnap.exists()) {
    const userData = userSnap.data();
    const option = document.createElement("option");
    option.value = userData.displayName || userData.email || uid;
    assigneeListEl.appendChild(option);
  }
}

document.getElementById("taskAssignee").value = currentUser.displayName || currentUser.email;
// Tooltip init
const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
  return new bootstrap.Tooltip(tooltipTriggerEl);
});




// Live preview task text
const newTaskInput = document.getElementById("newTask");
newTaskInput.addEventListener("input", () => {
  const val = newTaskInput.value;
  const preview = document.getElementById("taskPreview");
  if (val.startsWith("http")) {
    preview.innerHTML = `<a href="${val}" target="_blank">Preview Link</a>`;
  } else {
    preview.textContent = "";
  }
});

// Live URL preview for taskLinks
const linksInput = document.getElementById("taskLinks");
linksInput.addEventListener("input", () => {
  const links = linksInput.value.split(",").map(l => l.trim()).filter(Boolean);
  const preview = document.getElementById("linkPreview");
  preview.innerHTML = links.map(link =>
    link.startsWith("http") ? `<a href="${link}" target="_blank">${link}</a>` : `<span class="text-danger">Invalid URL</span>`
  ).join("<br>");
});

// Deadline validation
const deadlineInput = document.getElementById("taskDeadline");
deadlineInput.addEventListener("change", () => {
  const date = new Date(deadlineInput.value);
  const now = new Date();
  if (date < now) {
    deadlineInput.classList.add("is-invalid");
  } else {
    deadlineInput.classList.remove("is-invalid");
  }
});
      const tasksArray = data.tasks || [];
      renderAllTasks(tasksArray);

      titleEl.innerText = data.title || "Untitled";
      descEl.innerText = data.description || "No description provided.";
      if (data.mediaLinks) {
        mediaPreview.innerHTML = data.mediaLinks.map(link => link.includes(".mp4") ? `<video src="${link}" controls class="w-100 mb-2"></video>` : `<img src="${link}" class="img-fluid mb-2"/>`).join("");
      }

      publicToggle.checked = !!data.isPublic;
      publicToggle.onchange = () => updateDoc(collabRef, { isPublic: publicToggle.checked });

      if (data.owner === currentUser.uid) editControls.classList.remove("d-none");



// ✅ Updated Chat Enhancements for Collab Board

function timeSince(timestamp) {
  const now = Date.now();
  const seconds = Math.floor((now - timestamp) / 1000);

  if (seconds < 60) return `${seconds}s ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;

  const days = Math.floor(hours / 24);
  if (days < 7) return `${days}d ago`;

  // Show full date for anything older than a week
  return new Date(timestamp).toLocaleString(undefined, {
    month: "short",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  });
}


// 2. Handle Sending
sendChat.onclick = async () => {
  const html = chatInput.innerHTML.trim();
  if (!html) return;

  const newMsg = {
    id: crypto.randomUUID(),
    sender: currentUser.displayName || currentUser.email,
    content: html,
    timestamp: Date.now(),
    reactions: {},
    uid: currentUser.uid
  };

  const docRef = doc(db, "messages", collabId);
  const docSnap = await getDoc(docRef);

  let msgs = [];
  if (docSnap.exists()) {
    msgs = docSnap.data().messages || [];
  }

  msgs.push(newMsg);

  // 🔁 Use setDoc if doc doesn't exist, updateDoc if it does
  if (docSnap.exists()) {
    await updateDoc(docRef, { messages: msgs });
  } else {
    await setDoc(docRef, { messages: msgs });
  }

  chatInput.innerHTML = "";
};

// 3. Grouped Message Rendering
function renderGroupedMessages(messages) {
  chatBox.innerHTML = "";
  const grouped = {};
  messages.forEach(msg => {
    const dateKey = new Date(msg.timestamp).toLocaleDateString();
    grouped[dateKey] = grouped[dateKey] || [];
    grouped[dateKey].push(msg);
  });

  Object.entries(grouped).forEach(([date, msgs]) => {
    chatBox.innerHTML += `<div class='text-center text-muted small mb-1'>${date}</div>`;
    msgs.forEach(msg => renderMessage(msg));
  });

  chatBox.scrollTop = chatBox.scrollHeight;
}

function renderMessage(msg) {
  const timeAgo = timeSince(msg.timestamp);
  const reactionsHtml = Object.entries(msg.reactions || {}).map(([emoji, users]) =>
    `<span class='me-2 reaction-btn' data-emoji='${emoji}'>${emoji} ${users.length}</span>`
  ).join("");

  const fileIcon = msg.content.match(/(\.pdf|\.docx|\.mp4|\.zip)/i) ?
    `<i class='bi bi-file-earmark'></i> ` : "";

  chatBox.innerHTML += `
    <div class="msg mb-2 p-2 bg-light rounded" data-id="${msg.id}">
      <div class="fw-bold">${msg.sender}</div>
      <div>${fileIcon}${sanitize(msg.content)}</div>
      <div class="small text-muted mt-1 d-flex justify-content-between">
<span title="${new Date(msg.timestamp).toLocaleString()}">${timeAgo}</span>
        <span class="d-flex gap-2">
          ${reactionsHtml}
          ${msg.uid === currentUser.uid ? `<button class='btn btn-sm btn-link edit-btn'>✏️</button><button class='btn btn-sm btn-link delete-btn text-danger'>🗑️</button>` : ""}
        </span>
      </div>
    </div>
  `;
}

// 4. React to messages
chatBox.addEventListener("click", async (e) => {
  if (e.target.classList.contains("reaction-btn")) {
    const emoji = e.target.dataset.emoji;
    const msgId = e.target.closest(".msg")?.dataset.id;
    if (!msgId) return;

    const docRef = doc(db, "messages", collabId);
    const docSnap = await getDoc(docRef);
    const messages = docSnap.data()?.messages || [];

    const updatedMessages = messages.map(msg => {
      if (msg.id !== msgId) return msg;

      const reactions = msg.reactions || {};
      const users = reactions[emoji] || [];

      const updatedUsers = users.includes(currentUser.uid)
        ? users.filter(uid => uid !== currentUser.uid)
        : [...users, currentUser.uid];

      return {
        ...msg,
        reactions: {
          ...reactions,
          [emoji]: updatedUsers
        }
      };
    });

    await updateDoc(docRef, { messages: updatedMessages });
  }
});


// 5. Edit/Delete
chatBox.addEventListener("click", async (e) => {
  const msgEl = e.target.closest(".msg");
  const msgId = msgEl.dataset.id;
  const docRef = doc(db, "messages", collabId);
  const docSnap = await getDoc(docRef);
  const messages = docSnap.data()?.messages || [];
  const msg = messages.find(m => m.id === msgId);

  if (e.target.classList.contains("edit-btn")) {
    chatInput.innerHTML = msg.content;
    messages.splice(messages.indexOf(msg), 1);
    await updateDoc(docRef, { messages });
  }

  if (e.target.classList.contains("delete-btn")) {
    const confirmed = confirm("Delete this message?");
    if (confirmed) {
      await updateDoc(docRef, {
        messages: messages.filter(m => m.id !== msgId)
      });
    }
  }
});

// 6. Load Messages
onSnapshot(doc(db, "messages", collabId), docSnap => {
  const msgs = docSnap.data()?.messages || [];
  renderGroupedMessages(msgs);
});

chatInput.addEventListener("keyup", async (e) => {
  const selection = window.getSelection();
  const range = selection.getRangeAt(0);
  const caretRect = range.getBoundingClientRect();

  const text = chatInput.innerText;
  const lastWord = text.split(/\s/).pop();
  if (lastWord.startsWith("@") && lastWord.length > 1) {
    const query = lastWord.slice(1);
    showMentionDropdown(query, caretRect);
  } else {
    hideMentionDropdown();
  }
});



let mentionList = [];

function showMentionDropdown(query, caretRect) {
  const dropdown = document.getElementById("mentionsDropdown");
  const matches = mentionList.filter(u => u.displayName.toLowerCase().includes(query.toLowerCase()));

  if (!matches.length) return hideMentionDropdown();

  dropdown.innerHTML = matches.map(user =>
    `<button class="dropdown-item" data-uid="${user.uid}" data-name="${user.displayName}">@${user.displayName}</button>`
  ).join("");

  dropdown.style.left = `${caretRect.left}px`;
  dropdown.style.top = `${caretRect.bottom}px`;
  dropdown.style.display = "block";
}

function hideMentionDropdown() {
  const dropdown = document.getElementById("mentionsDropdown");
  dropdown.style.display = "none";
}


document.getElementById("mentionsDropdown").addEventListener("click", (e) => {
  if (!e.target.matches(".dropdown-item")) return;
  const name = e.target.dataset.name;
  const selection = window.getSelection();
  const range = selection.getRangeAt(0);
  range.deleteContents();
  const node = document.createTextNode(`@${name} `);
  range.insertNode(node);
  range.setStartAfter(node);
  selection.removeAllRanges();
  selection.addRange(range);
  hideMentionDropdown();
});

// Run this on load
async function loadMentionList() {
  const qSnap = await getDocs(collection(db, "users"));
  mentionList = qSnap.docs.map(doc => ({
    uid: doc.id,
    displayName: doc.data().displayName || doc.data().email
  }));
}
loadMentionList();


let draggedTaskId = null;


const pinBtn = document.createElement("button");
pinBtn.textContent = "📌 Pin";
pinBtn.className = "btn btn-sm btn-outline-warning";
pinBtn.onclick = async () => {
  const pinnedTasks = (data.pinnedTasks || []);
  if (!pinnedTasks.includes(taskObj.text)) {
    await updateDoc(collabRef, { pinnedTasks: arrayUnion(taskObj.text) });
  
  await addToTimeline("pinned_task", taskObj.text);
}
};

function renderPinnedTasks(pinnedTexts, tasks) {
  const pinnedSection = document.createElement("div");
  pinnedSection.innerHTML = "<h6>📌 Pinned Tasks</h6>";
  pinnedTexts.forEach(text => {
    const task = tasks.find(t => t.text === text);
    if (task) pinnedSection.appendChild(renderTask(task, true));
  });
  taskList.prepend(pinnedSection);
}

function updateProgressBar(tasks) {
  const total = tasks.length;
  const done = tasks.filter(t => t.completed).length;
  const percent = total ? Math.round((done / total) * 100) : 0;
  document.getElementById("progressBarFill").style.width = `${percent}%`;
  document.getElementById("progressBarFill").textContent = `${percent}% Complete`;
}

function renderAllTasks(tasksArray) {
  const taskList = document.getElementById("taskList");
  taskList.innerHTML = ""; // Clear first

  const sorted = tasksArray.sort((a, b) => (a.order || 0) - (b.order || 0));

  // Fetch pinned task texts from Firestore (you can pass this in if already loaded)
  getDoc(collabRef).then(docSnap => {
    const pinnedTexts = docSnap.data().pinnedTasks || [];

    // Render pinned tasks first
    if (pinnedTexts.length > 0) {
      renderPinnedTasks(pinnedTexts, sorted);
    }

    // Render the rest of the tasks (excluding pinned ones if you want)
    sorted.forEach(task => {
      if (!pinnedTexts.includes(task.text)) {
        renderTask(task);
      }
    });

    // Update progress bar
    updateProgressBar(sorted);
  });
}

function renderTask(taskObj) {
  const taskList = document.getElementById("taskList");

  const taskDiv = document.createElement("div");
  taskDiv.className = "task border rounded p-3 mb-2 bg-white shadow-sm";
  taskDiv.draggable = true;
  taskDiv.dataset.id = taskObj.text;

  taskDiv.ondragstart = () => draggedTaskId = taskObj.text;
  taskDiv.ondragover = e => e.preventDefault();
  taskDiv.ondrop = async () => {
    if (draggedTaskId !== taskObj.text) {
      const docSnap = await getDoc(collabRef);
      const tasks = docSnap.data().tasks || [];
      const draggedTask = tasks.find(t => t.text === draggedTaskId);
      const dropTask = tasks.find(t => t.text === taskObj.text);
      if (draggedTask && dropTask) {
        const temp = draggedTask.order;
        draggedTask.order = dropTask.order;
        dropTask.order = temp;
        await updateDoc(collabRef, { tasks });
        renderAllTasks(tasks);
      }
    }
  };

  // === HEADER (Task title + checkbox)
  const taskHeader = document.createElement("div");
  taskHeader.className = "d-flex justify-content-between align-items-center mb-2";

  const taskText = document.createElement("span");
  taskText.textContent = taskObj.text;
  taskText.className = taskObj.completed ? "text-decoration-line-through" : "";

const checkbox = document.createElement("input");
checkbox.type = "checkbox";
checkbox.className = "form-check-input";
checkbox.checked = taskObj.completed || false;

checkbox.addEventListener("change", async () => {
  const isCompleted = checkbox.checked;
  const updatedTask = { ...taskObj, completed: isCompleted };

  const docSnap = await getDoc(collabRef);
  const data = docSnap.data();
  const tasks = (data.tasks || []).filter(t => t.text !== taskObj.text);
  tasks.push(updatedTask);

  await updateDoc(collabRef, { tasks });

  // Update UI
  taskText.classList.toggle("text-decoration-line-through", isCompleted);

  // Log to timeline
  const status = isCompleted ? "✔️ Completed" : "❌ Marked as Not Completed";
  const timelineMsg = `"${taskObj.text}" → ${status}`;
  await addToTimeline("checked_task", timelineMsg);

  // ✅ Update progress bar
  updateProgressBar(tasks);
});


  taskHeader.append(taskText, checkbox);
  taskDiv.appendChild(taskHeader);

  // === META INFO ROW
  const metaRow = document.createElement("div");
  metaRow.className = "small text-muted d-flex flex-wrap gap-3 mb-2";

  if (taskObj.goal) metaRow.innerHTML += `<span>🎯 <strong>Goal:</strong> ${taskObj.goal}</span>`;
  if (taskObj.order !== null && taskObj.order !== undefined) metaRow.innerHTML += `<span>🔢 <strong>Order:</strong> ${taskObj.order}</span>`;
  if (taskObj.deadline) {
    const dueDate = new Date(taskObj.deadline);
    const friendlyDate = dueDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    const isOverdue = Date.now() > dueDate.getTime();
    const deadlineClass = isOverdue ? "text-danger fw-bold" : "";
    metaRow.innerHTML += `<span class="${deadlineClass}">🕒 <strong>Due:</strong> ${friendlyDate}</span>`;
  }
  if (taskObj.assignee) metaRow.innerHTML += `<span>👤 <strong>Assigned:</strong> ${taskObj.assignee}</span>`;
  if (taskObj.links?.length) metaRow.innerHTML += `<span>📎 <strong>Links:</strong> ${taskObj.links.join(", ")}</span>`;

  taskDiv.appendChild(metaRow);

  // === OPTIONAL CHECKLIST
  if (taskObj.checklist?.length) {
    const checklist = document.createElement("ul");
    (taskObj.checklist || []).forEach(item => {
      const li = document.createElement("li");
      li.textContent = item;
      checklist.appendChild(li);
    });
    taskDiv.appendChild(checklist);
  }

  // === FOOTER: comment + buttons
  const footer = document.createElement("div");
  footer.className = "mt-3";

  const commentBox = document.createElement("textarea");
  commentBox.className = "form-control form-control-sm mb-2";
  commentBox.placeholder = "Add comment...";
  commentBox.value = taskObj.comment || "";
  commentBox.addEventListener("blur", async () => {
    const docSnap = await getDoc(collabRef);
    const data = docSnap.data();
    const tasks = data.tasks.map(t => t.text === taskObj.text ? { ...t, comment: commentBox.value } : t);
    await updateDoc(collabRef, { tasks });
  });

  const btnGroup = document.createElement("div");
  btnGroup.className = "d-flex gap-2";

  const editBtn = document.createElement("button");
  editBtn.className = "btn btn-sm btn-outline-primary";
  editBtn.textContent = "Edit";
  editBtn.onclick = () => {
    document.getElementById("newTask").value = taskObj.text;
    document.getElementById("taskGoal").value = taskObj.goal;
    document.getElementById("taskOrder").value = taskObj.order;
    document.getElementById("taskDeadline").value = taskObj.deadline;
    document.getElementById("taskAssignee").value = taskObj.assignee || "";
    document.getElementById("taskLinks").value = (taskObj.links || []).join(", ");
    deleteTask(taskObj.text);
  };

  const delBtn = document.createElement("button");
  delBtn.className = "btn btn-sm btn-outline-danger";
  delBtn.textContent = "Delete";
  delBtn.onclick = () => deleteTask(taskObj.text);

  btnGroup.append(editBtn, delBtn);

  footer.appendChild(commentBox);
  footer.appendChild(btnGroup);
  taskDiv.appendChild(footer);

  taskList.appendChild(taskDiv);
}

async function deleteTask(taskText) {
  const docSnap = await getDoc(collabRef);
  const tasks = (docSnap.data().tasks || []).filter(t => t.text !== taskText);
  await updateDoc(collabRef, { tasks });
  renderAllTasks(tasks);
  await addToTimeline("deleted_task", taskText);

}

addTask.onclick = async () => {
  const taskText = document.getElementById("newTask").value.trim();
  const goal = document.getElementById("taskGoal").value.trim();
  const order = parseInt(document.getElementById("taskOrder").value);
  const deadline = document.getElementById("taskDeadline").value;
  const assignee = document.getElementById("taskAssignee").value.trim();
  const links = document.getElementById("taskLinks").value.split(",").map(l => l.trim()).filter(Boolean);

  if (!taskText) return;

  const taskObj = {
    text: taskText,
    goal: goal || "General",
    order: isNaN(order) ? null : order,
    deadline: deadline || null,
    timestamp: Date.now(),
    completed: false,
    createdBy: currentUser.uid,
    checklist: [],
    links,
    assignee
  };

await updateDoc(collabRef, {
  tasks: arrayUnion(taskObj)
});
await addToTimeline("added_task", taskText);


  const updatedDoc = await getDoc(collabRef);
  renderAllTasks(updatedDoc.data().tasks || []);

  document.getElementById("newTask").value = "";
  document.getElementById("taskGoal").value = "";
  document.getElementById("taskOrder").value = "";
  document.getElementById("taskDeadline").value = "";
  document.getElementById("taskAssignee").value = "";
  document.getElementById("taskLinks").value = "";
};




      if (data.timeline?.length) {
  renderTimeline(data.timeline);
}


// ✅ Add to Timeline w/ full user object
async function addToTimeline(type, details) {
  const userDoc = await getDoc(doc(db, "users", currentUser.uid));
  const user = userDoc.exists() ? userDoc.data() : {};

  const entry = {
    user: {
      displayName: user.displayName || currentUser.displayName || currentUser.email,
      email: user.email || currentUser.email,
      role: user.role || "member",
      photoURL: user.photoURL || null
    },
    type,
    details,
    timestamp: Date.now()
  };

  // Push to Firestore
  await updateDoc(collabRef, { timeline: arrayUnion(entry) });

  // Optionally: Update UI immediately
  if (typeof renderTimeline === "function") {
    const docSnap = await getDoc(collabRef); // Fetch latest timeline
    const updatedTimeline = docSnap.data().timeline || [];
    renderTimeline(updatedTimeline);
  }
}





document.getElementById("editCollab").onclick = async () => {
  const newTitle = prompt("Edit Title", data.title);
  const newDesc = prompt("Edit Description", data.description);

  await updateDoc(collabRef, { title: newTitle, description: newDesc });

  await addToTimeline("updated_collab", "Changed title/description");
};

    }


  </script>
  <script type="module">
    const footer = await fetch('https://rw-501.github.io/contenthub/includes/footer.html').then(res => res.text());
    document.getElementById('footerContainer').innerHTML = footer;
    import('https://rw-501.github.io/contenthub/includes/footer.js');
  </script>


</body>
</html>
